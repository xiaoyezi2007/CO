# P3_Logisim_单周期CPU设计文档
## 模块1：IFU
端口定义如下：  
| 信号名 | 方向 | 描述 |
| :----:| :----: | :---- |
| PC[31:0] | I | 下一条指令地址 |
| clk | I | 时钟信号 |
| reset | I | 异步复位信号 |
| Instr[31:0] | O | 取出的32位指令信号 |  
| pc[31:0] | O | 该条指令的地址 |

实现方法：用12位地址、32位数据的ROM作为IM。将PC-0x3000存入储存PC的寄存器中，寄存器中的值可以直接对应ROM要获取指令的地址，从而完成指令输出。

## 模块2：GRF
端口定义如下：  
| 信号名 | 方向 | 描述 |
| :----:| :----: | :---- |
| clk | I | 时钟信号 |
| reset | I | 异步复位信号 |
| WE | I | 写入使能信号 |
| A1[4:0] | I | 指定一个寄存器并将其中储存的数据读出到RD1 |
| A2[4:0] | I | 指定一个寄存器并将其中储存的数据读出到RD2 |
| A3[4:0] | I | 指定一个寄存器并将其作为写入数据的目标 |
| WD[31:0] | I | 要写入的数据 |
| RD1[31:0] | O | A1指定寄存器中的数据 |
| RD2[31:0] | O | A2指定寄存器中的数据 |

实现方法：WE为高电平时，利用DMX将WD输入到指定寄存器中。同时利用MUX，用A1，A2作为选择信号将32个寄存器中的值选择性输出。  
该模块直接使用P0中搭建的GRF。

## 模块3：ALU
端口定义如下：
| 信号名 | 方向 | 描述 |
| :----:| :----: | :---- |
| num1[31:0] | I | 第一个运算数 |
| num2[31:0] | I |第二个运算数|
| ALUop[3:0] | I | 运算类型的选择信号 |
| ans[31:0] | O | 输出运算结果 |

其中，ALUop与运算类型的对应关系如下：
| ALUop | 操作 |
| :---: | :----|
| 0000 | num1 + num2 |
| 0001 | num1 - num2 |
| 0010 | num1 \| num2 |
| 0011 | num1 > num2 ? 1 : 0 |
| 0100 | num1 == num2 ? 1 : 0 |
| 0101 | num1 < num2 ? 1 : 0 |

实现方法：使用运算相关器件计算出各种运算的结果，再通过MUX，以ALUop作为选择信号，将需要的运算结果输入至ans。

## 模块4：DM
端口定义如下：  
| 信号名 | 方向 | 描述 |
| :----:| :----: | :---- |
| clk | I | 时钟信号 |
| reset | I | 异步复位信号 |
| WE | I | 写入使能信号 |
| WD[31:0] | I | 要写入的数据 |
| addr[11:0] | I | 访问的地址 |
| RD[31:0] | O | 读出地址处的数据 |

实现方法：采用12位地址，32位数据的RAM实现。将各个输入信号与RAM连接即可。**需要注意，在WE为0时DM会持续读出数据，所以读出的数据需要在模块外进行选择是否采用**。

## 模块5：EXT
端口定义如下：  
| 信号名 | 方向 | 描述 |
| :----:| :----: | :---- |
| in[15:0] | I | 需要位扩展的16位整数 |
| EXTop[1:0] | I | 位扩展类型选择信号 |
| out[31:0] | O | 位扩展结果 |

其中，EXTop与位扩展类型对应关系如下：
| EXTop | 操作 |
| :---: | :----|
| 00 | 将in进行符号位扩展到32位 |
| 01 | 将in进行高位零扩展到32位 |
| 10 | 将in加载到高16位，低位补0 |
| 11 | 将in符号扩展到32位并左移两位 |

实现方法：EXTop为00和01的操作直接由bit Extender实现，EXTop为10的操作由splitter实现，最终由MUX选择正确的操作结果输出。

## 模块6：Controller
端口定义如下：
| 信号名 | 方向 | 描述 |
| :----:| :----: | :---- |
| op[5:0] | I | 命令中最高的6位op部分 |
| func[5:0] | I | 命令中最低的6位func部分 |
| MemWrite | O | 是否写入内存 |
| RegWrite | O | 是否写入寄存器 |
| EXTop[1:0] | O | EXT的操作类型 |
| ALUSrc | O |第二个输入ALU的数是立即数还是寄存器中的值，1代表立即数 |
| RegDst | O | 命令中刻画写入寄存器的位数，1代表[20:16],0代表[15:11] |
| MemtoReg | O | 是否将内存输入寄存器，1代表是 |
| nPC_sel | O | 是否改变pc |
| ALUop[2:0] | O | ALU的操作类型 |

实现方法：参考P3教程，将整个Controller分为与逻辑和或逻辑两部分，需要的输出信号也在教程中给出。与逻辑中，op与func按位输入和逻辑模块，参考MIPS指令文档，
用与门判断op和func的各个位是否与某指令的op与func相同，若全部相同则点亮指令对应输出，反之保持低电平。  
或逻辑中，将与逻辑各个指令对应的输出直接输入，注意到这些输入只会有一个位置为高电平。设置或逻辑的输出信号为上述Controller的输出信号，
依次判断每条指令是否需要点亮对应信号，若需要点亮，则连一条线接入对应输出的或门即可。该部分在教程中比较详细。  

## 顶层搭建
制作模块的意义在于将一些操作封装，对于任意一条指令，我们要做的就是确定是否执行该操作，以及如何进行该操作，而这两个问题的答案正是由Controller的输出信号所刻画的。
所以，针对教程中所给的Controller输出信号，大体能得到一些连线想法：  
MemWrite，RegWrite：可以看作DM与GRF的使能信号。  
EXTop：刻画EXT的操作类型，应该直接输入EXT。  
ALUSrc：刻画ALU的输入数，所以应该使用一个MUX，将立即数和寄存器中的值输入MUX并用ALUsrc选择。  
RegDst：刻画GRF的一个输入，所以将指令中[20:16]与[15:11]两部分输入MUX并用RegDst选择，并输入GRF。  
MemtoReg：刻画输入GRF的数据WD，将内存读出的数据与ALU输出数据输入MUX并用MemtoReg选择，并作为WD输入GRF。  
ALUop：刻画ALU的操作类型，直接输入ALU。  
至此，我们已经将除IFU外的所有部件连接在一起了，接下来只需要连接IFU。  
首先将IFU取出的指令通过splitter，参考指令机器码结构分成各个部分，op与func直接输入Controller，指示寄存器编号的部分输入GRF，立即数输入
ALUSrc对应的MUX的输入即可。  
然后，剩下PC未处理，将下一条指令以及要跳转的指令接入MUX，根据ALU作比较得出的结果以及nPC_sel信号来决定下一个PC应该取何值。  
最后，将题目要求的输出通过tunnel在对应位置连出。下班收工！

## 反思
第一次搭建CPU花费总时长为9h，当然实际上有三分之一时间是在markdown里记录自己模块的端口和实现方法。一开始我一直
有一个非常困扰的问题，每个指令的结构与功能都不相同，如何让这些指令在一个相同的顶层电路之下正常工作？直到看到了Controller输出信号，
才发现这完全由这些控制信号辅助决定，不需要担心，如果读取的方式不对，那么控制信号会帮助我们不采取这种方式获得的数据，从而保证正确性。而且，观察到这些指令实际上结构非常相似
（毕竟设计出来就是为了喂给CPU的），这对我们的模块化搭建提供了极大便利。

## 测试方法
使用MIPS编写了数个仅由实现的若干指令组成的程序，用MARS导出后导入IFU，手动操控CPU时钟变化，同时在MARS中进行单步运行，通过两边程序运行的一致性检测CPU是否有问题。
官网下载logisim-generic-2.7.1.jar，尝试导出电路输出。
使用C语言稍微写了一个随机命令生成并输出标准答案，与输出对比文件差异即可大概确定是否正确。

## 思考题
1.上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。  
**答：IFU储存指令状态、GRF储存寄存器状态、DM储存内存状态；ALU、EXT、Controller、均参与状态转移**  
2.现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。  
**答：合理。IM中存储的指令不会修改，而是在用户编译后保持不变，使用ROM只读不写可以保护指令不被改变；GRF使用Register，因为只需要存储32个值，并且在一个时钟周期之内需要同时取出多个值；DM使用RAM，内存可读可写，同时可存储空间较大**  
3.在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。  
**答：设计了Controller中的与逻辑与或逻辑两个模块。分别判断输入的指令是何种指令以及输出该类指令所输出的CPU控制信号。设计思路：将指令中的op与func输入与逻辑模块，用与门判断并点亮对应指令的信号。**
**或逻辑则是输入指令类型的信号，而后将信号连接对应的或门输出控制信号**  
4.事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？  
**答：nop不产生任何影响，而不加入控制信号真值表，则任何控制信号都不会点亮，所以既不会写入寄存器也不会写入内存也不会跳转PC，也就是没有产生影响**  
5.阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。  
**答：强度尚可，所有类型指令均测试到。但对于sw与lw指令，括号内数值没有改变，未考虑offset为负数情况，没有测试目标寄存器为$0的情况；对于add没有进行溢出测试；对于beq没有测试跳转指令在该条指令之前或是该条指令的情况**